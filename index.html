<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D STL File Viewer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the 3D viewer and page layout */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* A light grey background */
        }
        #viewer-container {
            width: 100%;
            height: 60vh; /* Viewport height for the viewer */
            max-height: 700px;
            background-color: #e2e8f0; /* A slightly darker grey for the viewer background */
            border-radius: 0.75rem; /* Rounded corners */
            cursor: grab;
        }
        #viewer-container:active {
            cursor: grabbing;
        }
        canvas {
            display: block; /* Remove default bottom margin */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-4xl">
        <!-- Header Section -->
        <header class="text-center mb-6">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">3D STL File Viewer</h1>
            <p class="mt-2 text-md text-gray-600">Upload an .stl file to view it in 3D. Drag to rotate, scroll to zoom, right-click and drag to pan.</p>
        </header>

        <!-- Main Content -->
        <main class="bg-white p-6 rounded-xl shadow-lg">
            <!-- File Upload Section -->
            <div class="flex flex-col items-center justify-center mb-6">
                <label for="file-upload" class="relative cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                    </svg>
                    Upload STL File
                </label>
                <input id="file-upload" type="file" class="hidden" accept=".stl">
                <p id="file-name" class="mt-3 text-sm text-gray-500">No file selected.</p>
            </div>

            <!-- 3D Viewer Container -->
            <div id="viewer-container" class="relative shadow-inner">
                 <!-- Placeholder text -->
                <div id="placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500">
                    <p>3D Preview will appear here</p>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>Powered by <a href="https://threejs.org/" target="_blank" class="text-blue-500 hover:underline">Three.js</a></p>
        </footer>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera manipulation -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- STLLoader for loading STL files -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
        // Main script for the 3D viewer
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('viewer-container');
            const fileInput = document.getElementById('file-upload');
            const fileNameDisplay = document.getElementById('file-name');
            const placeholder = document.getElementById('placeholder');

            let scene, camera, renderer, controls, model;

            // --- Initialization ---
            function init() {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xe2e8f0); // Match container background

                // Camera
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.z = 50;

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                scene.add(directionalLight);
                
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight2.position.set(-50, -50, -50);
                scene.add(directionalLight2);

                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                controls.minDistance = 10;
                controls.maxDistance = 500;

                // Animation loop
                animate();
            }

            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            // --- File Handling ---
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // Update UI
                fileNameDisplay.textContent = file.name;
                if (placeholder) {
                    placeholder.style.display = 'none';
                }

                // Remove previous model if it exists
                if (model) {
                    scene.remove(model);
                }

                // Read and load the file
                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = e.target.result;
                    const loader = new THREE.STLLoader();
                    const geometry = loader.parse(contents);
                    
                    // Create material
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x007bff, // A nice blue color
                        metalness: 0.1,
                        roughness: 0.5,
                    });

                    // Create mesh
                    model = new THREE.Mesh(geometry, material);

                    // Center the model and scale it appropriately
                    centerAndFitModel(model);

                    scene.add(model);
                };
                reader.readAsArrayBuffer(file);
            });

            // --- Utility Functions ---
            function centerAndFitModel(object) {
                const boundingBox = new THREE.Box3().setFromObject(object);
                const center = boundingBox.getCenter(new THREE.Vector3());
                const size = boundingBox.getSize(new THREE.Vector3());

                // Center the object
                object.position.sub(center);

                // Scale the object to fit the view
                const maxDim = Math.max(size.x, size.y, size.z);
                const fitHeightDistance = maxDim / (2 * Math.tan(camera.fov * Math.PI / 360));
                const fitWidthDistance = fitHeightDistance / camera.aspect;
                const distance = 1.2 * Math.max(fitHeightDistance, fitWidthDistance);

                camera.position.z = distance;
                camera.far = distance * 2;
                camera.updateProjectionMatrix();

                controls.target.copy(new THREE.Vector3(0,0,0));
                controls.update();
            }

            // --- Window Resize Handling ---
            window.addEventListener('resize', () => {
                if (!renderer) return;
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            // --- Start the application ---
            init();
        });
    </script>
</body>
</html>
